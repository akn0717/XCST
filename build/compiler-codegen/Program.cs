using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Xcst.Compiler;

namespace XcstCodeGen {

   class Program {

      const string
      _fileExt = "xcst";

      readonly Uri
      _projectUri;

      public
      Program(Uri projectUri) {
         _projectUri = projectUri;
      }

      static string
      RootNamespace(XDocument projectDoc, string projectPath) {

         XNamespace xmlns = projectDoc.Root.Name.Namespace;

         return projectDoc.Root
            .Element(xmlns + "PropertyGroup")
            .Element(xmlns + "RootNamespace")?.Value
            ?? Path.GetFileNameWithoutExtension(projectPath);
      }

      static string
      Nullable(XDocument projectDoc) {

         XNamespace xmlns = projectDoc.Root.Name.Namespace;

         return projectDoc.Root
            .Element(xmlns + "PropertyGroup")
            .Element(xmlns + "Nullable")?.Value;
      }

      static string
      FileNamespace(Uri fileUri, Uri startUri, string rootNamespace) {

         string ns = rootNamespace;

         string relativePath = startUri.MakeRelativeUri(fileUri).OriginalString;

         if (relativePath.Contains("/")) {

            string relativeDir = startUri.MakeRelativeUri(new Uri(Path.GetDirectoryName(fileUri.LocalPath), UriKind.Absolute))
               .OriginalString;

            ns = String.Join(".", new[] { ns }.Concat(
               relativeDir
                  .Split('/')
                  .Select(n => CleanIdentifier(n))));
         }

         return ns;
      }

      // Transforms invalid identifier (class, namespace, variable) characters
      static string
      CleanIdentifier(string identifier) =>
         Regex.Replace(identifier, "[^a-z0-9_]", "_", RegexOptions.IgnoreCase);

      // Show compilation errors on Visual Studio's Error List
      // Also makes the error on the Output window clickable
      static void
      VisualStudioErrorLog(CompileException ex) {

         string uriString = ex.ModuleUri;
         string path = (Uri.TryCreate(uriString, UriKind.Absolute, out Uri uri) && uri.IsFile) ?
            uri.LocalPath
            : uriString;

         Console.WriteLine($"{path}({ex.LineNumber}): XCST error {ex.ErrorCode}: {ex.Message}");
      }

      void
      Run(TextWriter output) {

         var startUri = new Uri(_projectUri, ".");

         var compilerFact = new XcstCompilerFactory {
            EnableExtensions = true
         };

         XcstCompiler compiler = compilerFact.CreateCompiler();
         compiler.PackageFileDirectory = startUri.LocalPath;
         compiler.PackageFileExtension = _fileExt;
         compiler.IndentChars = "   ";
         compiler.CompilationUnitHandler = href => output;

         XDocument projectDoc = XDocument.Load(_projectUri.LocalPath);

         string rootNamespace = RootNamespace(projectDoc, _projectUri.LocalPath);
         string nullable = Nullable(projectDoc);

         if (nullable != null) {
            compiler.NullableAnnotate = true;
            compiler.NullableContext = nullable;
         }

         output.WriteLine("//------------------------------------------------------------------------------");
         output.WriteLine("// <auto-generated>");
         output.WriteLine("//     This code was generated by a tool.");
         output.WriteLine("//");
         output.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
         output.WriteLine("//     the code is regenerated.");
         output.WriteLine("// </auto-generated>");
         output.WriteLine("//------------------------------------------------------------------------------");

         foreach (string file in Directory.EnumerateFiles(startUri.LocalPath, "*." + _fileExt, SearchOption.AllDirectories)) {

            var fileUri = new Uri(file, UriKind.Absolute);
            string fileName = Path.GetFileName(file);
            string fileBaseName = Path.GetFileNameWithoutExtension(file);

            // Ignore files starting with underscore
            if (fileName[0] == '_') {
               continue;
            }

            compiler.TargetNamespace = FileNamespace(fileUri, startUri, rootNamespace);
            compiler.TargetClass = CleanIdentifier(fileBaseName);
            compiler.TargetBaseTypes = null;

            CompileResult xcstResult;

            try {
               xcstResult = compiler.Compile(fileUri);

            } catch (CompileException ex) {
               VisualStudioErrorLog(ex);
               throw;
            }
         }
      }

      public static void
      Main(string[] args) {

         string currentDir = Environment.CurrentDirectory;

         if (currentDir.Last() != Path.DirectorySeparatorChar) {
            currentDir += Path.DirectorySeparatorChar;
         }

         var callerBaseUri = new Uri(currentDir, UriKind.Absolute);
         var projectUri = new Uri(callerBaseUri, args[0]);
         var outputUri = new Uri(projectUri, "xcst.generated.cs");

         using (var output = File.CreateText(outputUri.LocalPath)) {

            // Because XML parsers normalize CRLF to LF,
            // we want to be consistent with the additional content we create
            output.NewLine = "\n";

            new Program(projectUri)
               .Run(output);
         }
      }
   }
}
